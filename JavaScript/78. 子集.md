# [78. 子集](https://leetcode-cn.com/problems/subsets/)

## 1. DFS

在函数中直接改变了 temp ，因此 res.push() 必须是一个浅复制（slice）的数组，不然到最后 temp 都为空数组

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function (nums) {
    let res = [];
    function dfs(index, temp) {
        res.push(temp.slice());
        for(let i = index; i < nums.length; i ++) {
            temp.push(nums[i]);
            dfs(i + 1, temp)
            temp.pop();
        }
    }
    dfs(0, []);
    return res;
};
```

在传参中改变了 temp，没有使用浅复制

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function (nums) {
    let res = [];
    function dfs(temp, index) {
        res.push(temp);
        for(let i = index; i < nums.length; i ++) {
            dfs(temp.concat([nums[i]]), i+1);
        }
    }
    dfs([], 0)
    return res;
};
```

## 2. 举例

我们可以看到第一个test执行完成后，arr 变为 [1, 2, 3, 3]，**在函数中改变了 arr**，那么第二个test执行时的 arr 就变成了 [1, 2, 3, 3]

```javascript
function test(i,arr) {
    if (i>2) {
        return;
    }
    i ++;
    arr.push(3)            
    console.log(i)
    console.log(arr)
    test(i,arr);  # 第 1 个 test
    test(i,arr);  # 第 2 个 test
}

test(1,[1,2])
```

这是输出结果

```javascript
2
(3) [1, 2, 3]
3
(4) [1, 2, 3, 3]
3
[1, 2, 3, 3, 3]
```

