# [78. 子集](https://leetcode-cn.com/problems/subsets/)

## 1. DFS

这个题目带来的思考很多，**按照一开始我的想法是没有 temp.pop()，但发现 temp 会累积，也就是说参数temp也会跟着改变。**

下面这种解法**在函数中直接改变了 temp，如 `temp.append()` 和 `temp.pop()`**。`res.append(temp[:])`  是浅复制了 temp（试过copy()但是报错）。

```python
class Solution(object):
    def subsets(self, nums):
        res = []
        self.dfs(nums, 0, [], res)
        return res

    def dfs(self, nums, index, temp, res):
        res.append(temp[:])
        print(res)                         # 调试打印，提交时要去掉
        for i in range(index, len(nums)):
            temp.append(nums[i])
            self.dfs(nums, i+1, temp, res)
            temp.pop()

```

下面这种解法**没有在函数中直接改变 temp，而是改变了在传参过程中的 temp**。没有用到浅复制。

```python
class Solution(object):
    def subsets(self, nums):
        res = []
        self.dfs(nums, 0, [], res)
        return res

    def dfs(self, nums, index, temp, res):
        res.append(temp)
        print(res)                        # 调试打印，提交时要去掉
        for i in range(index, len(nums)):
            self.dfs(nums, i+1, temp+[nums[i]], res)

```

这是调试信息

```python
[[]]
[[], [1]]
[[], [1], [1, 2]]
[[], [1], [1, 2], [1, 2, 3]]
[[], [1], [1, 2], [1, 2, 3], [1, 3]]
[[], [1], [1, 2], [1, 2, 3], [1, 3], [2]]
[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3]]
[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]
```

**最后总结：如果在函数中改变了引用类型的值，那么对应的形参也会相应改变，改变非引用类型的值不会改变**

